// Import Workbox (assuming it's available globally via next-pwa or a CDN import)
// If not, you might need to import directly: import * as workboxWindow from 'workbox-window';
// For a custom service worker, you'd typically use:
// importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'); // Or your chosen version

if (typeof workbox !== 'undefined') {
  console.log(`Workbox is loaded ðŸŽ‰`);

  const { registerRoute } = workbox.routing;
  const { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } = workbox.strategies;
  const { CacheableResponsePlugin } = workbox.cacheableResponse;
  const { ExpirationPlugin } = workbox.expiration;
  const { precacheAndRoute, cleanupOutdatedCaches } = workbox.precaching;
  const { BackgroundSyncPlugin } = workbox.backgroundSync;
  // offlineFallback is not a direct Workbox v6 module, but a recipe.
  // For custom SW, you'd implement similar logic or use a simpler fallback.

  cleanupOutdatedCaches();

  // Precache all assets defined in self.__WB_MANIFEST (generated by next-pwa or Workbox build process)
  // Ensure this manifest is correctly generated and available.
  // If self.__WB_MANIFEST is not populated, precaching will not work as expected.
  precacheAndRoute(self.__WB_MANIFEST || []);

  // Cache images with CacheFirst strategy
  registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
      cacheName: 'fibroguardian-images',
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200], // Cache opaque responses and successful responses
        }),
        new ExpirationPlugin({
          maxEntries: 100, // Increased max entries
          maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
        }),
      ],
    })
  );

  // Cache CSS, JS, and fonts with StaleWhileRevalidate strategy
  registerRoute(
    ({ request }) =>
      request.destination === 'style' ||
      request.destination === 'script' ||
      request.destination === 'worker' || // For web workers
      request.destination === 'font',
    new StaleWhileRevalidate({
      cacheName: 'fibroguardian-static-resources',
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 50, // Max 50 static resources
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        }),
      ],
    })
  );

  // API data with NetworkFirst strategy for most GET requests
  registerRoute(
    ({ url, request }) => url.pathname.startsWith('/api/') && request.method === 'GET',
    new NetworkFirst({
      cacheName: 'fibroguardian-api-responses',
      networkTimeoutSeconds: 5, // Timeout for network request before falling back to cache
      plugins: [
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
        new ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 1 * 60 * 60, // 1 hour for API GET responses
        }),
      ],
    })
  );

  // Offline fallback for navigation (HTML pages)
  // This requires an /offline.html page at the root of your public folder
  const networkOnlyNavigation = new NetworkOnly();
  const navigationHandler = async (params) => {
    try {
      return await networkOnlyNavigation.handle(params);
    } catch (error) {
      // Fallback to the offline page if network fails
      return caches.match('/offline.html');
    }
  };
  registerRoute(
    ({ request }) => request.mode === 'navigate',
    navigationHandler
  );
  
  // Background Sync for mutations
  const backgroundSyncPlugin = new BackgroundSyncPlugin('fibroguardian-offline-mutations', {
    maxRetentionTime: 48 * 60, // Retry for 48 hours (in minutes)
    onSync: async ({ queue }) => {
      let entry;
      while ((entry = await queue.popRequest())) { // Use popRequest to get and remove
        try {
          await fetch(entry.request.clone()); // Clone request before fetching
          console.log('Background sync successful for:', entry.request.url);
        } catch (error) {
          console.error('Background sync failed for:', entry.request.url, error);
          // Re-queue the request if it failed and should be retried
          // (BackgroundSyncPlugin handles retries automatically based on its config)
          // If you want to stop retrying after a certain number of attempts,
          // you'd need custom logic here or rely on maxRetentionTime.
          // For now, let Workbox handle retries.
          // await queue.pushRequest(entry); // This would re-queue indefinitely if not careful
          throw error; // Throw to let Workbox know it failed and should retry later
        }
      }
    },
  });

  // Register routes that use background sync for POST, PUT, PATCH, DELETE
  const mutationMethods = ['POST', 'PUT', 'PATCH', 'DELETE'];
  registerRoute(
    ({ url, request }) => 
      (url.pathname.startsWith('/api/tasks') ||
       url.pathname.startsWith('/api/reflecties') ||
       url.pathname.startsWith('/api/task-logs') ||
       url.pathname.startsWith('/api/specialist-patienten') ||
       url.pathname.startsWith('/api/profiles')) && // Add other mutable API endpoints
      mutationMethods.includes(request.method.toUpperCase()),
    new NetworkOnly({ // Try network first, if fails, queue for background sync
      plugins: [backgroundSyncPlugin],
    })
  );

  // Skip waiting and claim clients for new service worker to take control immediately
  self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  });

  self.addEventListener('activate', (event) => {
    event.waitUntil(clients.claim());
  });

} else {
  console.log(`Workbox didn't load ðŸ˜¬`);
}
